{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback } from 'react';\nimport { overlayAPI, apiUtils } from '../services/api';\nexport const useOverlays = () => {\n  _s();\n  const [overlays, setOverlays] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  // Fetch all overlays\n  const fetchOverlays = useCallback(async () => {\n    setLoading(true);\n    setError(null);\n    try {\n      const data = await overlayAPI.getAll();\n      setOverlays(data);\n    } catch (error) {\n      const errorMessage = apiUtils.handleError(error, 'Failed to fetch overlays');\n      setError(errorMessage);\n      console.error('Error fetching overlays:', error);\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Create new overlay\n  const createOverlay = useCallback(async overlayData => {\n    try {\n      const response = await overlayAPI.create(overlayData);\n\n      // Refresh overlays to get the complete object\n      await fetchOverlays();\n      return response;\n    } catch (error) {\n      const errorMessage = apiUtils.handleError(error, 'Failed to create overlay');\n      setError(errorMessage);\n      throw error;\n    }\n  }, [fetchOverlays]);\n\n  // Update overlay\n  const updateOverlay = useCallback(async (id, updateData) => {\n    try {\n      await overlayAPI.update(id, updateData);\n\n      // Update local state optimistically\n      setOverlays(prevOverlays => prevOverlays.map(overlay => overlay._id === id ? {\n        ...overlay,\n        ...updateData,\n        updated_at: new Date().toISOString()\n      } : overlay));\n    } catch (error) {\n      // Refresh overlays on error to ensure consistency\n      await fetchOverlays();\n      const errorMessage = apiUtils.handleError(error, 'Failed to update overlay');\n      setError(errorMessage);\n      throw error;\n    }\n  }, [fetchOverlays]);\n\n  // Delete overlay\n  const deleteOverlay = useCallback(async id => {\n    try {\n      await overlayAPI.delete(id);\n\n      // Remove from local state\n      setOverlays(prevOverlays => prevOverlays.filter(overlay => overlay._id !== id));\n    } catch (error) {\n      // Refresh overlays on error to ensure consistency\n      await fetchOverlays();\n      const errorMessage = apiUtils.handleError(error, 'Failed to delete overlay');\n      setError(errorMessage);\n      throw error;\n    }\n  }, [fetchOverlays]);\n\n  // Bulk update overlays (for drag operations)\n  const batchUpdateOverlays = useCallback(async updates => {\n    try {\n      const responses = await overlayAPI.batchUpdate(updates);\n\n      // Check if all updates were successful\n      const hasErrors = responses.some(response => response.status === 'rejected');\n      if (hasErrors) {\n        console.warn('Some overlay updates failed:', responses);\n      }\n\n      // Update local state for successful updates\n      const successfulUpdates = updates.filter((_, index) => responses[index].status === 'fulfilled');\n      setOverlays(prevOverlays => {\n        const newOverlays = [...prevOverlays];\n        successfulUpdates.forEach(({\n          id,\n          data\n        }) => {\n          const index = newOverlays.findIndex(overlay => overlay._id === id);\n          if (index !== -1) {\n            newOverlays[index] = {\n              ...newOverlays[index],\n              ...data,\n              updated_at: new Date().toISOString()\n            };\n          }\n        });\n        return newOverlays;\n      });\n      return responses;\n    } catch (error) {\n      const errorMessage = apiUtils.handleError(error, 'Failed to update overlays');\n      setError(errorMessage);\n      throw error;\n    }\n  }, []);\n\n  // Toggle overlay visibility\n  const toggleOverlayVisibility = useCallback(async id => {\n    const overlay = overlays.find(o => o._id === id);\n    if (!overlay) return;\n    try {\n      await updateOverlay(id, {\n        visible: !overlay.visible\n      });\n    } catch (error) {\n      console.error('Error toggling overlay visibility:', error);\n      throw error;\n    }\n  }, [overlays, updateOverlay]);\n\n  // Get overlay by ID\n  const getOverlay = useCallback(id => {\n    return overlays.find(overlay => overlay._id === id);\n  }, [overlays]);\n\n  // Filter overlays by type\n  const getOverlaysByType = useCallback(type => {\n    return overlays.filter(overlay => overlay.type === type);\n  }, [overlays]);\n\n  // Get visible overlays\n  const getVisibleOverlays = useCallback(() => {\n    return overlays.filter(overlay => overlay.visible !== false);\n  }, [overlays]);\n\n  // Clear error\n  const clearError = useCallback(() => {\n    setError(null);\n  }, []);\n\n  // Refresh overlays (alias for fetchOverlays for external use)\n  const refreshOverlays = useCallback(async () => {\n    await fetchOverlays();\n  }, [fetchOverlays]);\n\n  // Validate overlay data\n  const validateOverlay = useCallback(overlayData => {\n    const errors = {};\n    if (!overlayData.type || !['text', 'logo'].includes(overlayData.type)) {\n      errors.type = 'Type must be either \"text\" or \"logo\"';\n    }\n    if (!overlayData.content) {\n      errors.content = 'Content is required';\n    }\n    if (!overlayData.position || typeof overlayData.position.x !== 'number' || typeof overlayData.position.y !== 'number') {\n      errors.position = 'Valid position coordinates are required';\n    }\n    if (!overlayData.size || typeof overlayData.size.width !== 'number' || typeof overlayData.size.height !== 'number') {\n      errors.size = 'Valid size dimensions are required';\n    }\n\n    // Position bounds checking\n    if (overlayData.position) {\n      if (overlayData.position.x < 0 || overlayData.position.y < 0) {\n        errors.position = 'Position coordinates must be non-negative';\n      }\n    }\n\n    // Size bounds checking\n    if (overlayData.size) {\n      if (overlayData.size.width <= 0 || overlayData.size.height <= 0) {\n        errors.size = 'Size dimensions must be positive';\n      }\n      if (overlayData.size.width > 1920 || overlayData.size.height > 1080) {\n        errors.size = 'Size dimensions are too large';\n      }\n    }\n    return {\n      isValid: Object.keys(errors).length === 0,\n      errors\n    };\n  }, []);\n\n  // Load overlays on hook initialization\n  useEffect(() => {\n    fetchOverlays();\n  }, [fetchOverlays]);\n\n  // Return hook interface\n  return {\n    // State\n    overlays,\n    loading,\n    error,\n    // Actions\n    createOverlay,\n    updateOverlay,\n    deleteOverlay,\n    batchUpdateOverlays,\n    toggleOverlayVisibility,\n    refreshOverlays,\n    clearError,\n    // Selectors\n    getOverlay,\n    getOverlaysByType,\n    getVisibleOverlays,\n    // Utilities\n    validateOverlay,\n    // Statistics\n    stats: {\n      total: overlays.length,\n      visible: overlays.filter(o => o.visible !== false).length,\n      text: overlays.filter(o => o.type === 'text').length,\n      logo: overlays.filter(o => o.type === 'logo').length\n    }\n  };\n};\n_s(useOverlays, \"1A9RR/vTzicBTvYg3MrWpTzVydI=\");","map":{"version":3,"names":["useState","useEffect","useCallback","overlayAPI","apiUtils","useOverlays","_s","overlays","setOverlays","loading","setLoading","error","setError","fetchOverlays","data","getAll","errorMessage","handleError","console","createOverlay","overlayData","response","create","updateOverlay","id","updateData","update","prevOverlays","map","overlay","_id","updated_at","Date","toISOString","deleteOverlay","delete","filter","batchUpdateOverlays","updates","responses","batchUpdate","hasErrors","some","status","warn","successfulUpdates","_","index","newOverlays","forEach","findIndex","toggleOverlayVisibility","find","o","visible","getOverlay","getOverlaysByType","type","getVisibleOverlays","clearError","refreshOverlays","validateOverlay","errors","includes","content","position","x","y","size","width","height","isValid","Object","keys","length","stats","total","text","logo"],"sources":["C:/Users/HP/OneDrive/Desktop/Projects/Livestream/frontend/src/hooks/useOverlays.js"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\r\nimport { overlayAPI, apiUtils } from '../services/api';\r\n\r\nexport const useOverlays = () => {\r\n  const [overlays, setOverlays] = useState([]);\r\n  const [loading, setLoading] = useState(false);\r\n  const [error, setError] = useState(null);\r\n\r\n  // Fetch all overlays\r\n  const fetchOverlays = useCallback(async () => {\r\n    setLoading(true);\r\n    setError(null);\r\n    \r\n    try {\r\n      const data = await overlayAPI.getAll();\r\n      setOverlays(data);\r\n    } catch (error) {\r\n      const errorMessage = apiUtils.handleError(error, 'Failed to fetch overlays');\r\n      setError(errorMessage);\r\n      console.error('Error fetching overlays:', error);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, []);\r\n\r\n  // Create new overlay\r\n  const createOverlay = useCallback(async (overlayData) => {\r\n    try {\r\n      const response = await overlayAPI.create(overlayData);\r\n      \r\n      // Refresh overlays to get the complete object\r\n      await fetchOverlays();\r\n      \r\n      return response;\r\n    } catch (error) {\r\n      const errorMessage = apiUtils.handleError(error, 'Failed to create overlay');\r\n      setError(errorMessage);\r\n      throw error;\r\n    }\r\n  }, [fetchOverlays]);\r\n\r\n  // Update overlay\r\n  const updateOverlay = useCallback(async (id, updateData) => {\r\n    try {\r\n      await overlayAPI.update(id, updateData);\r\n      \r\n      // Update local state optimistically\r\n      setOverlays(prevOverlays => \r\n        prevOverlays.map(overlay => \r\n          overlay._id === id \r\n            ? { ...overlay, ...updateData, updated_at: new Date().toISOString() }\r\n            : overlay\r\n        )\r\n      );\r\n    } catch (error) {\r\n      // Refresh overlays on error to ensure consistency\r\n      await fetchOverlays();\r\n      \r\n      const errorMessage = apiUtils.handleError(error, 'Failed to update overlay');\r\n      setError(errorMessage);\r\n      throw error;\r\n    }\r\n  }, [fetchOverlays]);\r\n\r\n  // Delete overlay\r\n  const deleteOverlay = useCallback(async (id) => {\r\n    try {\r\n      await overlayAPI.delete(id);\r\n      \r\n      // Remove from local state\r\n      setOverlays(prevOverlays => \r\n        prevOverlays.filter(overlay => overlay._id !== id)\r\n      );\r\n    } catch (error) {\r\n      // Refresh overlays on error to ensure consistency\r\n      await fetchOverlays();\r\n      \r\n      const errorMessage = apiUtils.handleError(error, 'Failed to delete overlay');\r\n      setError(errorMessage);\r\n      throw error;\r\n    }\r\n  }, [fetchOverlays]);\r\n\r\n  // Bulk update overlays (for drag operations)\r\n  const batchUpdateOverlays = useCallback(async (updates) => {\r\n    try {\r\n      const responses = await overlayAPI.batchUpdate(updates);\r\n      \r\n      // Check if all updates were successful\r\n      const hasErrors = responses.some(response => response.status === 'rejected');\r\n      \r\n      if (hasErrors) {\r\n        console.warn('Some overlay updates failed:', responses);\r\n      }\r\n      \r\n      // Update local state for successful updates\r\n      const successfulUpdates = updates.filter((_, index) => \r\n        responses[index].status === 'fulfilled'\r\n      );\r\n      \r\n      setOverlays(prevOverlays => {\r\n        const newOverlays = [...prevOverlays];\r\n        successfulUpdates.forEach(({ id, data }) => {\r\n          const index = newOverlays.findIndex(overlay => overlay._id === id);\r\n          if (index !== -1) {\r\n            newOverlays[index] = { \r\n              ...newOverlays[index], \r\n              ...data, \r\n              updated_at: new Date().toISOString() \r\n            };\r\n          }\r\n        });\r\n        return newOverlays;\r\n      });\r\n      \r\n      return responses;\r\n    } catch (error) {\r\n      const errorMessage = apiUtils.handleError(error, 'Failed to update overlays');\r\n      setError(errorMessage);\r\n      throw error;\r\n    }\r\n  }, []);\r\n\r\n  // Toggle overlay visibility\r\n  const toggleOverlayVisibility = useCallback(async (id) => {\r\n    const overlay = overlays.find(o => o._id === id);\r\n    if (!overlay) return;\r\n    \r\n    try {\r\n      await updateOverlay(id, { visible: !overlay.visible });\r\n    } catch (error) {\r\n      console.error('Error toggling overlay visibility:', error);\r\n      throw error;\r\n    }\r\n  }, [overlays, updateOverlay]);\r\n\r\n  // Get overlay by ID\r\n  const getOverlay = useCallback((id) => {\r\n    return overlays.find(overlay => overlay._id === id);\r\n  }, [overlays]);\r\n\r\n  // Filter overlays by type\r\n  const getOverlaysByType = useCallback((type) => {\r\n    return overlays.filter(overlay => overlay.type === type);\r\n  }, [overlays]);\r\n\r\n  // Get visible overlays\r\n  const getVisibleOverlays = useCallback(() => {\r\n    return overlays.filter(overlay => overlay.visible !== false);\r\n  }, [overlays]);\r\n\r\n  // Clear error\r\n  const clearError = useCallback(() => {\r\n    setError(null);\r\n  }, []);\r\n\r\n  // Refresh overlays (alias for fetchOverlays for external use)\r\n  const refreshOverlays = useCallback(async () => {\r\n    await fetchOverlays();\r\n  }, [fetchOverlays]);\r\n\r\n  // Validate overlay data\r\n  const validateOverlay = useCallback((overlayData) => {\r\n    const errors = {};\r\n    \r\n    if (!overlayData.type || !['text', 'logo'].includes(overlayData.type)) {\r\n      errors.type = 'Type must be either \"text\" or \"logo\"';\r\n    }\r\n    \r\n    if (!overlayData.content) {\r\n      errors.content = 'Content is required';\r\n    }\r\n    \r\n    if (!overlayData.position || typeof overlayData.position.x !== 'number' || typeof overlayData.position.y !== 'number') {\r\n      errors.position = 'Valid position coordinates are required';\r\n    }\r\n    \r\n    if (!overlayData.size || typeof overlayData.size.width !== 'number' || typeof overlayData.size.height !== 'number') {\r\n      errors.size = 'Valid size dimensions are required';\r\n    }\r\n    \r\n    // Position bounds checking\r\n    if (overlayData.position) {\r\n      if (overlayData.position.x < 0 || overlayData.position.y < 0) {\r\n        errors.position = 'Position coordinates must be non-negative';\r\n      }\r\n    }\r\n    \r\n    // Size bounds checking\r\n    if (overlayData.size) {\r\n      if (overlayData.size.width <= 0 || overlayData.size.height <= 0) {\r\n        errors.size = 'Size dimensions must be positive';\r\n      }\r\n      if (overlayData.size.width > 1920 || overlayData.size.height > 1080) {\r\n        errors.size = 'Size dimensions are too large';\r\n      }\r\n    }\r\n    \r\n    return {\r\n      isValid: Object.keys(errors).length === 0,\r\n      errors\r\n    };\r\n  }, []);\r\n\r\n  // Load overlays on hook initialization\r\n  useEffect(() => {\r\n    fetchOverlays();\r\n  }, [fetchOverlays]);\r\n\r\n  // Return hook interface\r\n  return {\r\n    // State\r\n    overlays,\r\n    loading,\r\n    error,\r\n    \r\n    // Actions\r\n    createOverlay,\r\n    updateOverlay,\r\n    deleteOverlay,\r\n    batchUpdateOverlays,\r\n    toggleOverlayVisibility,\r\n    refreshOverlays,\r\n    clearError,\r\n    \r\n    // Selectors\r\n    getOverlay,\r\n    getOverlaysByType,\r\n    getVisibleOverlays,\r\n    \r\n    // Utilities\r\n    validateOverlay,\r\n    \r\n    // Statistics\r\n    stats: {\r\n      total: overlays.length,\r\n      visible: overlays.filter(o => o.visible !== false).length,\r\n      text: overlays.filter(o => o.type === 'text').length,\r\n      logo: overlays.filter(o => o.type === 'logo').length,\r\n    }\r\n  };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}